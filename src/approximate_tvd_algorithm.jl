# A representation of a representation that can be censored, i.e. the value may
# lie beyond the calculated range
struct CensoredObservation
    v::Float64 # Observed value
    c::Int  # Censoring flag
end

function Base.:+(
    x::CensoredObservation,
    y::CensoredObservation,
)::CensoredObservation
    CensoredObservation(x.v + y.v, x.c + y.c)
end

# Given two homogeneous Markov processes with (possibly truncated) transition
# probabilities P and Q respectively, which are defined on the same state
# space and start from state p₀, simulate a path of length k from the process
# generated by P, and find the corresponding maximal coupling probability
# between this path and one generated from Q
function simulate_coupling_probability(
    rng::Random.AbstractRNG,
    p₀::Integer,
    k::Integer,
    P::Array{Float64,2},
    Q::Array{Float64,2}
)::CensoredObservation

    size(P) ≠ size(Q) && throw(DimensionMismatch("P and Q do not have the same state space"))
    size(P, 1) ≠ size(P, 2) && throw(DimensionMismatch("P and Q are not square matrices"))
    (p₀ < 0 || p₀ ≥ size(P, 1)) && throw(DomainError(p₀, "argument should be in the range [0, √|P| - 1]"))
    k ≥ 1 || throw(DomainError(k, "path length must be at least one"))

    transition_quantiles = Random.rand(rng, k)
    transition_indices = Array{Int}(undef, k + 1)
    transition_indices[1] = p₀

    for n ∈ 1:k
        cumulative_prob = 0.0
        for i ∈ 1:size(P, 1)
            cumulative_prob += P[transition_indices[n], i]
            if transition_quantiles[n] ≤ cumulative_prob
                transition_indices[n+1] = i
                break
            elseif i == size(P, 1)
                # Early return if P has been truncated to before the desired quantile,
                # indicating the data is censored
                return CensoredObservation(0, 1)
            end

        end
    end

    P_path_prob = 1
    Q_path_prob = 1

    for i ∈ 1:k
        P_path_prob *= P[transition_indices[i], transition_indices[i+1]]
        Q_path_prob *= Q[transition_indices[i], transition_indices[i+1]]
    end

    if P_path_prob == 0
        return CensoredObservation(0, 0)
    else
        return CensoredObservation(max((P_path_prob - Q_path_prob) / P_path_prob, 0), 0)
    end
end

# Given two homogeneous Markov processes with (possibly truncated) transition
# probabilities P and Q respectively, which are defined on the same state
# space and start from state p₀, simulate the total variation distance between
# them for paths of length k, for a given number of trials.
function approximate_tvd(
    rng::Random.AbstractRNG,
    num_trials::Integer,
    p₀::Integer,
    k::Integer,
    P::Array{Float64,2},
    Q::Array{Float64,2}
)::Float64

    num_trials ≥ 1 || throw(DomainError(num_trials, "there must be at least one trial"))

    accumulator = CensoredObservation(0, 0)
    for i ∈ 1:num_trials
        accumulator += simulate_coupling_probability(rng, p₀, k, P, Q)
    end

    accumulator.v / (num_trials - accumulator.c)
end